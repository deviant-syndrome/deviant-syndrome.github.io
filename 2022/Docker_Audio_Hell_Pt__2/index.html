<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  

  <title>Docker Audio Hell Pt. 2</title>
  <meta name="description" content="False Promises of POSIX-compatibility

In previous article we briefly touched upon evolution of audio playback and processing under Unix-like operating system. That was quite a ride, if you remember. Maintaining traditions firmly set in this blog, let’s ask ourselves a question, how can we make my experience with *NIX audio even more pathological. Any suggestions? Right! Let’s run it in Docker under MacOS.

Ok. Let’s first politely (for the most part) dismiss the obvious suggestions from the sane-minded people. This would be sure mixed with some old-man’s rumbling touching the peculiarity of his ill habits.
Q: Why not just install Wine on your host system? 
A: Being a mentally challenged paranoid I am, I have to state that I\m simply afraid. As of now, MacOS has completely dropped 32-bit support, the instructions of building and setting up Wine on those kind of systems looks like for building a portal to Hell. I’m not sure if I’m ready for that yet.

Q: Why not use a proper HyperVisor, instead of crippled Docker, which was not designed for those kinds of shenanigans anyway?
A: Two point here. First, I simply do not want to install another piece of heavyweight software on my laptop (which is, technically, not even mine). Haven’t I already have this Docker thing lying around and my dayjob makes me interact with it a lot. So why not utilise it for something useful? (depends, on how one defines “useful”, of course)

Q: What’s the use of some old Win32 application?  It does not fit the modern audio production standards at all. 
A: That’s just how I roll, sir/ma’m

On normal Unix-like systems, the host’s sound (and MIDI) hardware could be simply shared via plain docker device mountpoint, like:
# x11docker provides this setup with option --alsa.
docker run --rm --device /dev/snd ALSAIMAGE speaker-test


However, on our beloved slick 2+K$ tinfoil cans, we are going into…

">
  <meta name="author" content="Deviant Syndrome">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Docker Audio Hell Pt. 2">
  <meta name="twitter:description" content="False Promises of POSIX-compatibility

In previous article we briefly touched upon evolution of audio playback and processing under Unix-like operating system. That was quite a ride, if you remember. Maintaining traditions firmly set in this blog, let’s ask ourselves a question, how can we make my experience with *NIX audio even more pathological. Any suggestions? Right! Let’s run it in Docker under MacOS.

Ok. Let’s first politely (for the most part) dismiss the obvious suggestions from the sane-minded people. This would be sure mixed with some old-man’s rumbling touching the peculiarity of his ill habits.
Q: Why not just install Wine on your host system? 
A: Being a mentally challenged paranoid I am, I have to state that I\m simply afraid. As of now, MacOS has completely dropped 32-bit support, the instructions of building and setting up Wine on those kind of systems looks like for building a portal to Hell. I’m not sure if I’m ready for that yet.

Q: Why not use a proper HyperVisor, instead of crippled Docker, which was not designed for those kinds of shenanigans anyway?
A: Two point here. First, I simply do not want to install another piece of heavyweight software on my laptop (which is, technically, not even mine). Haven’t I already have this Docker thing lying around and my dayjob makes me interact with it a lot. So why not utilise it for something useful? (depends, on how one defines “useful”, of course)

Q: What’s the use of some old Win32 application?  It does not fit the modern audio production standards at all. 
A: That’s just how I roll, sir/ma’m

On normal Unix-like systems, the host’s sound (and MIDI) hardware could be simply shared via plain docker device mountpoint, like:
# x11docker provides this setup with option --alsa.
docker run --rm --device /dev/snd ALSAIMAGE speaker-test


However, on our beloved slick 2+K$ tinfoil cans, we are going into…

">
  
  <meta name="twitter:image" content="/images/favicons/favicon-194x194.png" />

  <meta property="og:type" content="article">
  <meta property="og:title" content="Docker Audio Hell Pt. 2">
  <meta property="og:description" content="False Promises of POSIX-compatibility

In previous article we briefly touched upon evolution of audio playback and processing under Unix-like operating system. That was quite a ride, if you remember. Maintaining traditions firmly set in this blog, let’s ask ourselves a question, how can we make my experience with *NIX audio even more pathological. Any suggestions? Right! Let’s run it in Docker under MacOS.

Ok. Let’s first politely (for the most part) dismiss the obvious suggestions from the sane-minded people. This would be sure mixed with some old-man’s rumbling touching the peculiarity of his ill habits.
Q: Why not just install Wine on your host system? 
A: Being a mentally challenged paranoid I am, I have to state that I\m simply afraid. As of now, MacOS has completely dropped 32-bit support, the instructions of building and setting up Wine on those kind of systems looks like for building a portal to Hell. I’m not sure if I’m ready for that yet.

Q: Why not use a proper HyperVisor, instead of crippled Docker, which was not designed for those kinds of shenanigans anyway?
A: Two point here. First, I simply do not want to install another piece of heavyweight software on my laptop (which is, technically, not even mine). Haven’t I already have this Docker thing lying around and my dayjob makes me interact with it a lot. So why not utilise it for something useful? (depends, on how one defines “useful”, of course)

Q: What’s the use of some old Win32 application?  It does not fit the modern audio production standards at all. 
A: That’s just how I roll, sir/ma’m

On normal Unix-like systems, the host’s sound (and MIDI) hardware could be simply shared via plain docker device mountpoint, like:
# x11docker provides this setup with option --alsa.
docker run --rm --device /dev/snd ALSAIMAGE speaker-test


However, on our beloved slick 2+K$ tinfoil cans, we are going into…

">
  <meta property="og:image" content="/images/favicons/favicon-194x194.png" />

  <link rel="apple-touch-icon" sizes="57x57" href="/images/favicons/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/images/favicons/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/images/favicons/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/images/favicons/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/images/favicons/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/images/favicons/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/images/favicons/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/images/favicons/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicons/apple-touch-icon-180x180.png">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-194x194.png" sizes="194x194">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-96x96.png" sizes="96x96">
  <link rel="icon" type="image/png" href="/images/favicons/android-chrome-192x192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/images/favicons/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="shortcut icon" href="/images/favicons/favicon.ico">
  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">
  
  <link rel="stylesheet" href="/css/main.css?1685261901345671000">
  <link rel="canonical" href="/2022/Docker_Audio_Hell_Pt__2/">
  <link rel="alternate" type="application/rss+xml" title="Deviant Syndrome" href="/feed.xml">
<script>
window.MathJax = {
  tex: {
      packages: ['base', 'ams', 'noerrors', 'noundefined'],
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: false
  },
  loader: {
    load: ['[tex]/noerrors']
  }
};

  window.MathJax = {
  startup: {
    ready: () => {
      console.log('MathJax is loaded, but not yet initialized');
      MathJax.startup.defaultReady();
      console.log('MathJax is initialized, and the initial typeset is queued');
    }
  }
};
</script>
<style>
  @font-face {
    font-family: 'alphaTab';
     src: url('/js/alphaTab/Font/Bravura.eot');
     src: url('/js/alphaTab/Font/Bravura.eot') format('embedded-opentype')
          , url('/js/alphaTab/Font/Bravura.woff') format('woff')
          , url('/js/alphaTab/Font/Bravura.etf') format('opentype')
          , url('/js/alphaTab/Font/Bravura.svg') format('svg');
     font-weight: normal;
     font-style: normal;
}
</style>
<link rel="stylesheet" type="text/css" href="/assets/notation.css"> 
<script
  src="https://code.jquery.com/jquery-3.4.1.min.js"
  integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
  crossorigin="anonymous"></script>
<script src="/js/mathjax/tex-chtml.js" id="MathJax-script" async></script>

<script src="/js/alphaTab/AlphaTab.js" async></script>
<script src="/js/audiojs/audio.min.js"></script>
<link  href="/js/nanogallery2/css/nanogallery2.min.css" rel="stylesheet" type="text/css">
<script  type="text/javascript" src="/js/nanogallery2/jquery.nanogallery2.min.js"></script>
<link rel="stylesheet" href="/css/main.css?1685261901345671000">
</head>


  <body>
    <span class="mobile btn-mobile-menu">
  <i class="icon icon-list btn-mobile-menu__icon"></i>
  <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
</span>

<header class="panel-cover" style="background-image: url(/images/cover.jpg)">
  <div class="panel-main">

    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">
        <a href="/" title="link to home of Deviant Syndrome">
          <img src="/images/profile.jpg" class="user-image" alt="My Profile Photo">
          <h1 class="panel-cover__title panel-title">Deviant Syndrome</h1>
        </a>
        <hr class="panel-cover__divider">
        <p class="panel-cover__description">coding, multimedia, gamedev, engineering</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="link to Deviant Syndrome blog" class="blog-button">Blog</a></li>
            </ul>
          </nav>

          <nav class="cover-navigation navigation--social">
            <ul class="navigation">

              <!-- Bandcamp -->
              <li class="navigation__item">
                <a href="http://hexensoldat.bandcamp.com" title="@Deviant Syndrome on Bandcamp"
                   target="_blank">
                  <i class="icon icon-social-bandcamp"></i>
                  <span class="label">Bandcamp</span>
                </a>
              </li>

              

            

            

            
              <!-- GitHub -->
              <li class="navigation__item">
                <a href="https://www.github.com/deviant-syndrome" title="deviant-syndrome on GitHub" target="_blank">
                  <i class="icon icon-social-github"></i>
                  <span class="label">GitHub</span>
                </a>
              </li>
            

            

            <!-- RSS -->
            <li class="navigation__item">
              <a href="/feed.xml" title="Subscribe" target="_blank">
                <i class="icon icon-rss"></i>
                <span class="label">RSS</span>
              </a>
            </li>

            </ul>
          </nav>

        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>


    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <article class="post-container post-container--single">
  <header class="post-header">
    <div class="post-meta">
      <time datetime="2022-08-21 17:26" class="post-meta__date date">21 Aug 2022</time>
      
      &#8226; <span class="post-meta__tags">on <a href="/tags/#docker">docker</a> <a href="/tags/#wine">wine</a> <a href="/tags/#pulseaudio">pulseaudio</a> </span>
      
    </div>
    <h1 class="post-title">Docker Audio Hell Pt. 2</h1>
  </header>

  <section class="post">
    <h4 id="false-promises-of-posix-compatibility">False Promises of POSIX-compatibility</h4>

<p>In <a href="/2022/Docker_Audio_Hell/">previous article</a> we briefly touched upon evolution of audio playback and processing under Unix-like operating system. That was quite a ride, if you remember. Maintaining traditions firmly set in this blog, let’s ask ourselves a question, how can we make my experience with *NIX audio even more pathological. Any suggestions? Right! Let’s run it in Docker under MacOS.</p>

<p>Ok. Let’s first politely (for the most part) dismiss the obvious suggestions from the sane-minded people. This would be sure mixed with some old-man’s rumbling touching the peculiarity of his ill habits.
Q: Why not just install Wine on your host system? 
A: Being a mentally challenged paranoid I am, I have to state that I\m simply afraid. As of now, MacOS has completely dropped 32-bit support, the instructions of building and setting up Wine on those kind of systems looks like for building a portal to Hell. I’m not sure if I’m ready for that yet.</p>

<p>Q: Why not use a proper HyperVisor, instead of crippled Docker, which was not designed for those kinds of shenanigans anyway?
A: Two point here. First, I simply do not want to install another piece of heavyweight software on my laptop (which is, technically, not even mine). Haven’t I already have this Docker thing lying around and my dayjob makes me interact with it a lot. So why not utilise it for something useful? (depends, on how one defines “useful”, of course)</p>

<p>Q: What’s the use of some old Win32 application?  It does not fit the modern audio production standards at all. 
A: That’s just how I roll, sir/ma’m</p>

<p>On normal Unix-like systems, the host’s sound (and MIDI) hardware could be simply shared via plain docker device mountpoint, like:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># x11docker provides this setup with option --alsa.</span>
docker run <span class="nt">--rm</span> <span class="nt">--device</span> /dev/snd ALSAIMAGE speaker-test
</code></pre></div></div>

<p>However, on our beloved slick 2+K$ tinfoil cans, we are going into…</p>

<!-- readmore -->

<h4 id="hoops-of-hellfire-and-blades">Hoops of Hellfire and Blades</h4>

<p>As an alternatively-abled, alternative OS (MacOS X) user, I do not have this luxury. The solution proposed, was to actually utilise pulseaudio native audio-over-the-network support. As I described earlier, conceptually it works, but I spotted two problems with that:</p>
<ul>
  <li>Some strange latency issues, latency increases over time, and requires me to periodically restart the server on my host OS.</li>
  <li>My version of pulseaudio, obtained from Homebrew (I believe), does not allow me to output to a virtual device (in my case, BlackHole 16ch)</li>
</ul>

<p>Seems, like the problem here is no particular device being virtual, but rather PulseAudio failing at creating sink name. See https://www.freedesktop.org/wiki/Software/PulseAudio/Documentation/User/SupportedAudioFormats/ . I could try to debug this, however, my attempts at building latest pulseaudio could be compared to monkey trying to land a fighter jet (no offence to the monkeys, through, I managed to build it, but then it failed to start, stating that my alternative OS semaphores are not POSIX compatible).</p>

<details>
  <summary>MacOS PulseAudio Server Logs
</summary>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I: [] module-coreaudio-device.c: Initializing module for CoreAudio device 'BlackHole 16ch' (id 52)
I: [] module-card-restore.c: Restoring port latency offsets for card BlackHole_16ch.
D: [] card.c: Looking for initial profile for card BlackHole_16ch
D: [] card.c: on availability unknown
I: [] card.c: BlackHole_16ch: active_profile: on
I: [] card.c: Created 0 "BlackHole_16ch"
D: [] module-coreaudio-device.c: Sample rate: 44100.000000
D: [] module-coreaudio-device.c: 64 bytes per packet
D: [] module-coreaudio-device.c: 1 frames per packet
D: [] module-coreaudio-device.c: 64 bytes per frame
D: [] module-coreaudio-device.c: 16 channels per frame
D: [] module-coreaudio-device.c: 32 bits per channel
D: [] module-coreaudio-device.c: Stream name is &gt;Channel 1, Channel 2, Channel 3, Channel 4, Channel 5, Channel 6, Channel 7, Channel 8, Channel 9, Channel 10, Channel 11, Channel 12, Channel 13, Channel 14, Channel 15, Channel 16&lt;
D: [] module-device-restore.c: Database contains no data for key: sink:Channel_1__Channel_2__Channel_3__Channel_4__Channel_5__Channel_6__Channel_7__Channel_8__Channel_9__Channel_10__Channel_11__Chann
D: [] module-device-restore.c: Database contains no (or invalid) data for key: sink:Channel_1__Channel_2__Channel_3__Channel_4__Channel_5__Channel_6__Channel_7__Channel_8__Channel_9__Channel_10__Channel_11__Chann:null
I: [] sink.c: Created sink 0 "Channel_1__Channel_2__Channel_3__Channel_4__Channel_5__Channel_6__Channel_7__Channel_8__Channel_9__Channel_10__Channel_11__Chann" with sample spec float32le 16ch 44100Hz and channel map mono,mono,mono,mono,mono,mono,mono,mono,mono,mono,mono,mono,mono,mono,mono,mono
I: [] sink.c:     device.string = "BlackHole 16ch"
I: [] sink.c:     device.product.name = "BlackHole 16ch"
I: [] sink.c:     device.description = "BlackHole 16ch"
I: [] sink.c:     device.access_mode = "mmap"
I: [] sink.c:     device.class = "sound"
I: [] sink.c:     device.api = "CoreAudio"
I: [] sink.c:     device.buffering.buffer_size = "32768"
I: [] sink.c:     device.vendor.name = "Existential Audio Inc."
I: [] sink.c:     device.icon_name = "audio-card"
D: [] source.c: Failed to register name Channel_1__Channel_2__Channel_3__Channel_4__Channel_5__Channel_6__Channel_7__Channel_8__Channel_9__Channel_10__Channel_11__Chann.monitor.
I: [] sink.c: Freeing sink 0 "Channel_1__Channel_2__Channel_3__Channel_4__Channel_5__Channel_6__Channel_7__Channel_8__Channel_9__Channel_10__Channel_11__Chann"
E: [] module-coreaudio-device.c: unable to create sink.
</code></pre></div>  </div>
</details>

<p>Those couple of issues mentioned above, of course, make recording the container’s audio output comparable to jumping through the hoops of hellfire and blades every tine. So, instead of that, I decided to use 
OulseAudio RTP sink support, which could be defined like that (on the host system):</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pulseaudio <span class="nt">--load</span><span class="o">=</span>module-native-protocol-tcp <span class="nt">--exit-idle-time</span><span class="o">=</span><span class="nt">-1</span> <span class="nt">-vvvvv</span>
<span class="c"># since we did not daemonize the serivce, the commands below can be executed in a separate terminal window</span>
pacmd load-module module-null-sink <span class="nv">sink_name</span><span class="o">=</span>rtp
pacmd load-module module-rtp-send <span class="nb">source</span><span class="o">=</span>rtp.monitor <span class="nv">port</span><span class="o">=</span>1234 <span class="nv">loop</span><span class="o">=</span>1
</code></pre></div></div>

<p><a href="https://en.wikipedia.org/wiki/Real-time_Transport_Protocol">RTP protocol</a> can work in two modes, standard single-cast and (multi-cast)[https://en.wikipedia.org/wiki/Real-time_Transport_Protocol]. So, if use define a sink with default options, . And unfortunately, you would never guess, what would be the mutkcast address, you’ll have to probe it manually, or grep pulseaudio logs. And this option only accetps single IP or multi-cast range, no hostname resolve supported. So, the “docker.io” tricks would not work here (the phrase “would not work” could be the most frequent word combination of this blog, need to check for that one day).</p>

<p>By the way, you can check the UDP communication between docker container and host using netcat.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># inside the container</span>
nc <span class="nt">-u</span> &lt;HOST_IP&gt; 1234

<span class="c"># on host machine</span>
nc <span class="nt">-ul</span> 1234 
</code></pre></div></div>

<p>And we are also have to do some exotic magic to simply obtain the host’s IP on the Docker network. Our life would be too easy and dull without that, wouldn’t it?</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># either an arbitrary IPv4 address from host</span>
<span class="nv">Hostip</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span>ip <span class="nt">-4</span> <span class="nt">-o</span> a | <span class="nb">awk</span> <span class="s1">'{print $4}'</span> | <span class="nb">cut</span> <span class="nt">-d</span>/ <span class="nt">-f1</span> | <span class="nb">grep</span> <span class="nt">-v</span> 127.0.0.1 | <span class="nb">head</span> <span class="nt">-n1</span><span class="si">)</span><span class="s2">"</span>

<span class="c"># or especially IP from docker daemon</span>
<span class="nv">Hostip</span><span class="o">=</span><span class="s2">"</span><span class="si">$(</span>ip <span class="nt">-4</span> <span class="nt">-o</span> a| <span class="nb">grep </span>docker0 | <span class="nb">awk</span> <span class="s1">'{print $4}'</span> | <span class="nb">cut</span> <span class="nt">-d</span>/ <span class="nt">-f1</span><span class="si">)</span><span class="s2">"</span>
</code></pre></div></div>

<p>Then why not simply define a loop back address and a free UDP port, by convention for RTP it’s 1234 (RTP usually uses UDP as a transport). Then we could simply forward this port from guest to host. Well, shocking news, ladies ang gentelmen, 
in Docker world, ports are forwared <em>from host to container</em>, not the other way around. So, if you are into that kind of naughty stuff, you\ll have to use dockers’s –network=host option. So, then you can determine the host’s IP and speicify it in the config. (Hack me gently with a chainsaw, but I do not remember, why loopback did not work in this case).</p>

<h4 id="6inks-6inks-6inks">6inks, 6inks, 6inks</h4>

<p>Aaaaaand, it works. Well, sort of. I was able to pass my audio to the <em>other side</em>. It was accompanied by a constant wall of digital noise, though. 
When I try to stream raw PCM audio using <code class="language-plaintext highlighter-rouge">faplay</code>, for example:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ffplay  <span class="nt">-sample_rate</span> 44100 <span class="nt">-autoexit</span> <span class="nt">-f</span> s16be rtp://127.0.0.1:1234
</code></pre></div></div>
<p>When I try to do the same, with, say, VLC player, it tries to interpret the data stream as some interleaved AV, and outputs all kind of glitchy weirdess in the video window.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vlc <span class="nt">--demux</span><span class="o">=</span>rawaud <span class="nt">--rawaud-channels</span><span class="o">=</span>2 <span class="nt">--rawaud-samplerate</span><span class="o">=</span>44100 udp://@:1234
</code></pre></div></div>

<p>First, I thought it was raw audio byte format problem, judging by the logs the defaul format is <code class="language-plaintext highlighter-rouge">s16be</code> (16 bit big-endian). Just to get gist of the lunacy factor, you can take a tour of audio byte format zoo <a href="https://www.freedesktop.org/wiki/Software/PulseAudio/Documentation/User/SupportedAudioFormats/">here</a></p>

<p>However, I made sure they are matching and it left me with nothing but two more flavoirs of digital audio pollution. Well, it’s time to reveal you the brutal truth. Pulseaudio RTP sinks are <em>multi-cast only</em>. So, when you specify a single IP address and port there, it dumps all the it’s sister RTP Control Stuff (stats, metadata and heartbeats) right above the raw audio, manifestating itself in a form a constant audiable noise.</p>

<p>So, I swithed to multicast, and now now I’m able to get the audio output from Docker container to my virtual device for recording. 
The latency is still there of course. Thankfully, I’m not obligated to perform live with this kind of setup.</p>

<h4 id="i-might-still-be-insane-though">I might still be insane, though</h4>

<p>PulseAudio has native mechanism for capturing audio. The monitor sink is created the similar way, and then, allegedly, you can pipe it anywhere.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pactl load-module module-null-sink <span class="nv">sink_name</span><span class="o">=</span>steam
parec <span class="nt">-d</span> steam.monitor | oggenc <span class="nt">-b</span> 192 <span class="nt">-o</span> steam.ogg <span class="nt">--raw</span> - 
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">oggenc</code> is just for example here. Raw stream can be encoded into anything. The thing I have not tested yet, is would the standard output still be available, as recording without monitoring is not fun at all. Trust me, I used to do that.</p>


  </section>
  
</article>



      </div>

      <footer class="footer">
  <span class="footer__copyright">&copy; 2023 Deviant Syndrome. All rights reserved.</span>
  <span class="footer__copyright">Based on <a href="https://github.com/joshgerdes/jekyll-uno">jekyll-uno</a> theme by Josh Gerdes</span>
</footer>

<script type="text/javascript" src="/js/main.js?1685261901345671000"></script>
<script type="text/javascript" src="/js/sheetrender.js"></script>
<script src="/js/audioplaylist.js"></script>	


    </div>
  </body>
</html>
